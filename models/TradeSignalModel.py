from pydantic import BaseModel, Field, model_validator, field_validator, ConfigDict
from typing import Optional, Dict, Any, List, Self
from datetime import datetime, timedelta
from enum import Enum


class TradeAction(str, Enum):
    BUY = "BUY"
    SELL = "SELL"


class SignalType(str, Enum):
    ENTRY = "ENTRY"
    EXIT = "EXIT"
    ADJUSTMENT = "ADJUSTMENT"


class TimeFrame(str, Enum):
    INTRADAY = "INTRADAY"
    DAILY = "DAILY"
    WEEKLY = "WEEKLY"
    MONTHLY = "MONTHLY"


class TradeSignalModel(BaseModel):
    """
    Model representing trading signals generated by Analyst Bots.

    This model captures all information needed for Trader Bots to execute trades,
    including action, asset, price targets, and risk parameters.
    """

    model_config = ConfigDict(
        frozen=True,
        extra="forbid",
        json_schema_extra={
            "example": {
                "schema_version": "1.0",
                "bot_id": "analyst_bot_1",
                "signal_id": "sig_12345",
                "timestamp": "2023-04-25T14:30:00Z",
                "action": "BUY",
                "confidence": 0.85,
                "asset": "AAPL",
                "market": "NASDAQ",
                "target_price": 150.25,
                "stop_loss": 145.75,
                "signal_type": "ENTRY",
                "notes": "This is a short-term momentum entry trade.",
                "tags": ["momentum", "short-term"],
                "priority": 7,
                "analysis_timeframe": "DAILY"
            }
        }
    )

    schema_version: str = Field(..., description="Version of the schema.")
    bot_id: str = Field(..., description="Identifier for the Analyst Bot generating the signal.")
    signal_id: str = Field(..., description="Unique identifier for the trade signal.")
    timestamp: datetime = Field(..., description="Timestamp when the signal was generated (ISO 8601).")
    action: TradeAction = Field(..., description="Action to be taken (BUY or SELL).")
    confidence: float = Field(..., ge=0, le=1, description="Confidence level of the signal from 0-1.")
    asset: str = Field(..., description="The financial instrument (e.g., stock, currency) for the trade.")
    market: str = Field(..., description="The market or exchange where the trade should be executed.")
    time_validity: Optional[datetime] = Field(None, description="Expiration time for the signal.")
    quantity: Optional[float] = Field(None, description="Quantity of asset to trade (in absolute units, not portfolio percentage).")
    quantity_type: Optional[str] = Field(
        "ABSOLUTE",
        description="Specifies if quantity is absolute units or portfolio percentage (ABSOLUTE or PERCENTAGE)."
    )
    strategy_id: Optional[str] = Field(None, description="Identifier of the strategy that generated the signal.")
    target_price: Optional[float] = Field(None, description="Target price for the trade.")
    stop_loss: Optional[float] = Field(None, description="Stop-loss price for the trade.")
    signal_type: Optional[SignalType] = Field(SignalType.ENTRY, description="Type of signal (ENTRY, EXIT, ADJUSTMENT).")
    notes: Optional[str] = Field(None, description="Optional comments or rationale for the trade.")
    tags: Optional[List[str]] = Field(default_factory=list, description="Optional tags or categories for the signal.")
    priority: Optional[int] = Field(5, ge=1, le=10, description="Priority of this signal (1-10, with 10 being highest).")
    risk_score: Optional[float] = Field(None, ge=0, le=10, description="Risk score of the trade (0-10, 10=highest risk).")
    expected_holding_period: Optional[timedelta] = Field(None, description="Expected holding period for this trade.")
    analysis_timeframe: Optional[TimeFrame] = Field(None, description="Timeframe used in the analysis generating this signal.")
    linked_signals: Optional[List[str]] = Field(default_factory=list, description="IDs of related signals.")
    source_data: Optional[Dict[str, Any]] = Field(default_factory=dict, description="Summary of data that led to this signal.")
    extra_data: Optional[Dict[str, Any]] = Field(default_factory=dict, description="Additional custom data.")

    @field_validator('asset')
    @classmethod
    def validate_asset(cls, v: str) -> str:
        """Validate asset symbol format."""
        if not v or not v.strip():
            raise ValueError("Asset symbol cannot be empty")
        if len(v.strip()) > 20:
            raise ValueError("Asset symbol too long")
        return v.strip().upper()

    @model_validator(mode="after")
    def validate_prices(self) -> Self:
        """Validate price relationships based on trade action."""
        if all(v is not None for v in [self.action, self.target_price, self.stop_loss]):
            if self.action == TradeAction.BUY and self.stop_loss >= self.target_price:
                raise ValueError("For BUY signals, stop_loss must be less than target_price")
            if self.action == TradeAction.SELL and self.stop_loss <= self.target_price:
                raise ValueError("For SELL signals, stop_loss must be greater than target_price")
        return self

    @model_validator(mode="after")
    def validate_expiration(self) -> Self:
        """Ensure time_validity is in the future."""
        if self.timestamp and self.time_validity and self.time_validity <= self.timestamp:
            raise ValueError("Signal expiration (time_validity) must be after signal generation timestamp")
        return self

